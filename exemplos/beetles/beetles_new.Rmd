---
title: "**Beetles** "
subtitle: "Regressão Logística - Análise de Dados Categorizados - Prova 3"
author: 
- Allan Vieira 14/0128492
- Caio Balena
- Frederico Lucca
- José Cezário

date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_folding: hide
    self_contained: false
    df_print: paged
---

<!-- self_contained: false --- para nao dar pau do plotly com firefox -->
<!-- df_print para as formas de imprimir data frames e tibbles -->
<!-- ver https://rmarkdown.rstudio.com/html_document_format.html -->

<!-- incluir no cabecalho: -->
<!-- always_allow_html: yes  -->
<!--para quando formos passar para pdf -->

<style>
body {
text-align: justify}
</style>

<!-- para justificar texto no markdown -->
<!-- https://stackoverflow.com/questions/43222169/how-to-justify-the-text-to-both-sides-when-knitting-html-in-rmarkdown -->

<!-- <style> -->
<!--   .col2 { -->
<!--     columns: 2 200px;         /* number of columns and width in pixels*/ -->
<!--     -webkit-columns: 2 200px; /* chrome, safari */ -->
<!--     -moz-columns: 2 200px;    /* firefox */ -->
<!--   } -->
<!--   .col3 { -->
<!--     columns: 3 100px; -->
<!--     -webkit-columns: 3 100px; -->
<!--     -moz-columns: 3 100px; -->
<!--   } -->
<!-- </style> -->
<!-- esse de cima funciona no output do RStudio, mas nao nos browsers -->
<!-- tb em: https://stackoverflow.com/questions/31753897/2-column-section-in-r-markdown -->


<!-- para acrescentar logo da unb no cabeçalho -->
<script>
   $(document).ready(function() {
     $head = $('#header');
     $head.prepend('<img src=\"unb3.png\" style=\"float: right;width: 150px;\"/>')
   });
</script>

---

---

<!-- ```{r, echo=FALSE} -->

<!-- htmltools::img(src = knitr::image_uri(file.path(R.home("doc"), "html", "logo.jpg")),  -->
<!--                alt = 'logo',  -->
<!--                style = 'position:absolute; top:0; right:0; padding:1px;') -->

<!-- ``` -->


**Carregamento de pacotes:**

Neste exemplo são utilizados os seguintes pacotes: *dplyr*, *magrittr*, *tibble*, *plotly*, *lmtest*, *ResouceSelection* e *modEvA*. Para a confecção do documento html, é necessário o pacote *rmarkdown*.

```{r, message=FALSE, warning=FALSE}
# dplyr -- para facilitar manipulacao de dados
if (!require('dplyr')) install.packages('dplyr'); library('dplyr')

# magrittr -- para facilitar manipulacao de dados
if (!require('magrittr')) install.packages('magrittr'); library('magrittr')

# tibble -- para facilitar manipulacao de dados
if (!require('tibble')) install.packages('tibble'); library('tibble')

# broom -- para facilitar manipulacao de dados
if (!require('broom')) install.packages('broom'); library('broom')

# plotly -- para os plots
if (!require('plotly')) install.packages('plotly'); library('plotly')

# lmtest -- para os testes de razao de verossimilhancas e para o teste de wald
if (!require('lmtest')) install.packages('lmtest'); library('lmtest')

# ResourceSelection -- para utilizar uma versão do teste de Hosmer Lemeshow
if (!require('ResourceSelection')) install.packages('ResourceSelection'); library('ResourceSelection')

# modEVA -- para compelemntar a funcao alternativa do teste de Hosmer Lemeshow
if (!require('modEvA')) install.packages('modEvA'); library('modEvA')

```

\s\s

**Carregamento dos dados**:

```{r}
dose <- c(1.6907, 1.7242, 1.7552, 1.7842, 1.8113, 1.8369, 1.8610, 1.8839)

killed <- c(6, 13, 18, 28, 52, 53, 61, 59)

total <- c(59, 60, 62, 56, 63, 59, 62, 60)

# criando uma coluna do outro resultado: x = 1 (survived); x = 0 (killed)
beetles <- tibble::data_frame(dose, killed, total) %>%
  dplyr::mutate(survived = total - killed, prop = killed/total)

beetles

```

\s\s


**Plot:**

```{r, fig.width=9}

beetles %>%
  #dplyr::mutate(color = factor(falhas)) %>%
  
  plotly::plot_ly(x=~dose, y=~prop, #group=~color,
                           type="scatter", mode="markers" #, color=~color, #split=~falhas
          ) %>%
  plotly::layout(title = "Beetle Mortality Data")


```

\s\s

**Ajuste do modelo**:

```{r}

resp <- as.matrix(
  beetles %>%
  dplyr::select(killed, survived)
)

fit <- glm(resp ~ dose, family=binomial(link="logit"))

summary(fit)

```

\s\s

\s\s

**-2logLik:**

\s\s

```{r, message=FALSE, warning=FALSE}
# -2logLik
-2*logLik(fit)
```

\s\s

**Int. Conf. OR:**
```{r, message=FALSE, warning=FALSE}
# OR
exp(confint.default(fit)) # o metodo *.default* assume normalidade assintotica, por isso eh utilizado.
```

\s\s

**Teste de Razão de Verossimilhanças:**
```{r, message=FALSE, warning=FALSE}
# 1) razao de verossimilhancas
#library(lmtest)
lmtest::lrtest(fit)
```

\s\s

**Teste de Wald:**
```{r, message=FALSE, warning=FALSE}
# 2) teste de Wald
lmtest::waldtest(fit)
```

\s\s

**Teste Score:**
```{r, message=FALSE, warning=FALSE}
# 3) Score
anova(fit,test="Rao")
```

\s\s

\s\s


\s\s

**Teste de Hosmer Lemeshow:**

No **R**, há métodos diferentes que implementam o teste de Hosmer Lemeshow. Abaixo, são apresentadas duas formas.

A primeira delas seria utilizando o modelo a partir do qual os dados foram ajustados na forma de tabela de frequências. Mas como nesse caso só há 8 observações, deve-se ajustar o parâmetro `g` (número de classes/intervalos) da função para um valor menor.

```{r, message=FALSE, warning=FALSE}

ResourceSelection::hoslem.test(fit$y, fit$fitted.values, g=5)

```

\s\s

A segunda forma é ajustando um novo modelo com base nos dados expandidos com a variável resposta na forma de zeros e uns (0,1). Assim ganham-se graus de liberdade e, consequentemente mais "espaço" para os intervalos. Note que na saída do modelo, tem-se exatamente os mesmos valores de coeficientes e de p-valor, mas valores diferentes para AIC, *deviance* etc. Essa diferença deve-se justamente ao maior número de observações que se tem agora. Na verdade, com essa configuração de dados, todas as sapidas (AIC, etc) passam a bater exatamente com as saídas do SAS.

```{r, message=FALSE}

beetles2 <- as.data.frame(beetles)

# antes do teste, eh necessario transformar para zero e uns
# o nao evento eh sobreviver
response_l <- lapply(1:nrow(beetles2), function(i){
  killed <- rep(c(0,1), c(beetles2[i,"survived"], beetles2[i,"killed"])) # response
  dose <- rep(beetles2[i,"dose"], length(killed)) # variable
  cbind(dose, killed)
})

beetles_newdata <- as.data.frame(Reduce(rbind, response_l))

fit2 <- glm(killed ~ dose, data=beetles_newdata, family=binomial(link="logit"))

summary(fit2) # os deviance, df e AIC diferentes enm relacao ao modelo 1 vem devido ao nro de linhas (obs) no modelo expandido


```

\s\s

Para o teste, foi feita uma pequena aleração na função *HLfit()* do pacote **modEvA**. O objetivo é replicar os resultados apresentados no output do **SAS** para o teste de *Hosmer Lemeshow*. Os ajustes  são para solucionar um *bug* da função e para fazer com que ela retorne também uma tabela das partições que foram geradas para o teste. Esta função é a única que tem retorno parecido com o do SAS porque permite escolher métodos diferentes para gerar os intervalos nos dados. No caso utilizamos `bin.method="quantile"`.

```{r, message=FALSE}
# library(modEvA)
# alteração da função HLfit:
HLfit2 <- function (model = NULL, obs = NULL, pred = NULL, bin.method, n.bins = 10, fixed.bin.size = FALSE, min.bin.size = 15, min.prob.interval = 0.1, simplif = FALSE) {
  # version 1.5 (24 Jun 2015)
  
  if (!is.null(model)) {
    if (!is.null(obs)) message("Argument 'obs' ignored in favour of 'model'.")
    if (!is.null(pred)) message("Argument 'pred' ignored in favour of 'model'.")
    obs <- model$y
    pred <- model$fitted.values
  }
  
  stopifnot(
    length(obs) == length(pred),
    obs %in% c(0, 1),
    pred >= 0,
    pred <= 1
  )
  
  bins <- getBins(obs = obs, pred = pred, bin.method = bin.method, n.bins = n.bins, fixed.bin.size = fixed.bin.size, min.bin.size = min.bin.size, min.prob.interval = min.prob.interval)
  n.bins <- nrow(bins$bins.table)
  
  # next 4 lines: adapted from hosmerlem function in http://www.stat.sc.edu/~hitchcock/diseaseoutbreakRexample704.txt
  observed <- xtabs(cbind(1 - obs, obs) ~ bins$prob.bin)
  expected <- xtabs(cbind(1 - pred, pred) ~ bins$prob.bin)
  chi.sq <- sum((observed - expected) ^ 2 / expected)
  p.value <- 1 - pchisq(chi.sq, df = n.bins - 2)
  rmse <- sqrt(mean((observed - expected) ^ 2))
  
  if (simplif) return(list(chi.sq = chi.sq, p.value = p.value, RMSE = rmse))
  
  # retiramos plot -- nosso ajuste!
  
  # nosso ajuste: partition table
  partition <- data.frame(cbind(matrix(observed[,2]), matrix(expected[,2])), 
                          cbind(matrix(observed[,1]), matrix(expected[,1])))
  
  colnames(partition) <- c("Observed_Event", "Expected_Event", "Observed_Nonevent", "Expected_Nonevent")
  
  return(list(partition = partition, stats = list(chi.sq = chi.sq, DF = n.bins - 2, p.value = p.value), RMSE = rmse))
}


```

```{r, message=FALSE, warning=FALSE}
out_HL <- HLfit2(model=fit2, bin.method = "quantiles", n.bins = 10) # ok!

tibble::as.tibble(out_HL$partition)
```

```{r, message=FALSE, warning=FALSE}
out_HL$stats
```

\s\s

**Ajustes pré-plotagem:**

```{r}

# criando obs artificiais para suavizar a curva
x_limits <- beetles %>%
  dplyr::summarise(min = min(dose), max = max(dose)) # obtendo os limites do eixo x

x <- seq(x_limits[[1]], x_limits[[2]], by=0.001) # criando varios ptos entre esses limites -- by precisa ser bem pequeno aqui

# obtendo os valores de y de acordo com os parametros da reg logist
y <- plogis(fit$coefficients[1]+fit$coefficients[2]*x)


# fazendo a predicao das obs artificiais
# ver sol: https://stackoverflow.com/questions/26694931/how-to-plot-logit-and-probit-in-ggplot2
temp.data = data.frame(dose = x) # se nao passar a coluna com o mesmo nome da variavel nao funciona


# Predict the fitted values given the model and hypothetical data
predicted.data <- as.data.frame(predict(fit, newdata = temp.data, 
                                        type="link", se=TRUE))

# Combine the hypothetical data and predicted values
new.data <- cbind(temp.data, predicted.data)

# Calculate confidence intervals
std <- qnorm(0.95 / 2 + 0.5)
new.data$ymin <- fit$family$linkinv(new.data$fit - std * new.data$se)
new.data$ymax <- fit$family$linkinv(new.data$fit + std * new.data$se)
new.data$fit <- fit$family$linkinv(new.data$fit)  # Rescale to 0-1


```


\s\s

**Plot:**
```{r, fig.width=9}

plotly::plot_ly(x = ~x, y = ~y, name = 'fitted', type = 'scatter', mode = 'lines') %>%
  plotly::add_trace(x= ~dose, y = ~prop, name = 'resp', mode = 'markers', data=beetles) %>%
  plotly::add_ribbons(data = new.data,
              ymin = ~ymin,
              ymax = ~ymax,
              line = list(color = 'rgba(138,43,226, 0.05)', opacity = 0.1),
              fillcolor = 'rgba(138,43,226, 0.2)', opacity = 0.25,
              name = "95% conf.") %>%
  plotly::layout(title = "Beetle Mortality Data")


```




---

#### EXTRA

---


\s\s

##### **Avaliando os resíduos**:

**Plots resíduos vs valores ajustados:**


<!-- para dividir a saida em 2 colunas com css-- eh a unica que funciona no browser!! -->
<!-- https://stackoverflow.com/questions/31753897/2-column-section-in-r-markdown -->
<!-- NAO FUNCIONA COM PLOTLY APENAS COM DYGRAPHS!!!! -->



```{r}
# outra forma de colocar os graficos lado a lado com plotly
# plotly::subplot(p2, p3)

```


```{r, fig.width=9}
# colcando tudo no mesmo gráfico

# se usarmos ~variavel ele traz os nomes das variaveis nos eixos
plotly::plot_ly(x = fit$fitted.values, y = residuals(fit), 
                      name = 'Deviance', type = 'scatter', mode = 'markers' ) %>%
  # plotly::layout(title = "Resíduos Deviance", xaxis = list(title="fitted"), yaxis = list(title="resíduos")) %>%
  plotly::add_trace(x = fit$fitted.values, y = ~fit$residuals, 
                      name = 'Pearson', type = 'scatter', mode = 'markers') %>%
  plotly::layout(title = "Resíduos", xaxis = list(title="fitted"), yaxis = list(title="resíduos") )
  
```

\s\s

Com intervalo de confiança:

```{r}
# library(plotly)
# library(broom)
# https://plot.ly/r/graphing-multiple-chart-types/#loess-smoother-with-uncertainty-bounds

m2 <- loess(residuals(fit) ~ fit$fitted.values)

p2 <- plotly::plot_ly(x = fit$fitted.values, 
                      y = residuals(fit)) %>% # nao posso colocar a cor aqui
  plotly::add_markers(marker = list( color = "blue"), name = "Deviance" ) %>% # tenho que adicionar uma cama especifica para alterar a cor
  plotly::add_lines(y = ~fitted(loess(residuals(fit) ~ fit$fitted.values)),
            line = list(color = 'rgba(138,43,226, 0.5)'), # o ultimo valor eh opacity
            # cores em decimal em: https://reeddesign.co.uk/test/namedcolors.html
            name = "Loess Smoother") %>% 
  plotly::add_ribbons(data = broom::augment(m2),
              ymin = ~.fitted - qnorm(0.975) * .se.fit,
              ymax = ~.fitted + qnorm(0.975) * .se.fit,
              line = list(color = 'rgba(138,43,226, 0.05)', opacity = 0.1),
              fillcolor = 'rgba(138,43,226, 0.2)', opacity = 0.25,
              name = "Standard Error") %>%
  plotly::layout(title = "Resíduos Deviance", 
                 xaxis = list(title="fitted"), 
                 yaxis = list(title="resíduos"))




m3 <- loess(fit$residuals ~ fit$fitted.values)

p3 <- plotly::plot_ly(x = fit$fitted.values, y = fit$residuals) %>%
  plotly::add_markers(marker = list( color = "orange"), name = "Pearson" ) %>% # tenho que adicionar uma cama especifica para alterar a cor
  plotly::add_lines(y = ~fitted(loess(fit$residuals ~ fit$fitted.values)),
            line = list(color = 'rgba(138,43,226, 0.5)'),
            name = "Loess Smoother") %>%
  plotly::add_ribbons(data = broom::augment(m3),
              ymin = ~.fitted - qnorm(0.975) * .se.fit,
              ymax = ~.fitted + qnorm(0.975) * .se.fit,
              line = list(color = 'rgba(138,43,226, 0.05)', opacity = 0.1),
              fillcolor = 'rgba(138,43,226, 0.2)', opacity = 0.25,
              name = "Standard Error") %>%
  plotly::layout(title = "Resíduos de Pearson", 
                 xaxis = list(title="fitted"), 
                 yaxis = list(title="resíduos"))


```



<div class = "row">
<div class = "col-md-6">

```{r, fig.height=4, fig.width=4.7}
p2
```

</div>
<div class = "col-md-6">

```{r, fig.height=4, fig.width=4.7}
p3
```

</div>
</div>


##### **Medidas (diagnóstico) de influência**


**Resíduos vs índices**

```{r, message=FALSE}
# ou com plotly:
library(dplyr)
# pontos e linhas no mesmo plot:
# https://plot.ly/r/line-and-scatter/

p2 <- plotly::plot_ly(x = 1:length(residuals(fit)), y = residuals(fit), 
                      name = 'prop', type = 'scatter', mode = 'markers', marker = list( color = "blue") ) %>%
  plotly::layout(title = "Resíduos Deviance", xaxis = list(title="índices"), yaxis = list(title="resíduos"))

p3 <- plotly::plot_ly(x = 1:length(residuals(fit)), y = ~fit$residuals, 
                      name = 'prop', type = 'scatter', mode = 'markers', marker = list( color = "green") )  %>%
  plotly::layout(title = "Resíduos de Pearson", xaxis = list(title="índices"), yaxis = list(title="resíduos"))
  
# se usarmos ~variavel ele traz os nomes das variaveis nos eixos
```


<div class = "row">
<div class = "col-md-6">

```{r, fig.height=4, fig.width=4}
p2
```

</div>
<div class = "col-md-6">

```{r, fig.height=4, fig.width=4}
p3
```

</div>
</div>



```{r}

medinflu <-influence.measures(fit)
inf_measures <- tibble::as.tibble(medinflu$infmat)
inf_measures

```

\s\s
Plotando valores de leverage (*hat*), *dffit*, *dfbeta* (para dose) e *cook distance*:


```{r}
# separando as 4 medidas de interesse

inf_measures_sub <- inf_measures %>%
  dplyr::select(dfb.dose, dffit, cook.d, hat)

```


```{r}
# 1 plot para cada coluna
lista <- lapply(1:ncol(inf_measures_sub),
            function(j) {
              plotly::plot_ly(x = 1:nrow(inf_measures_sub),
                      y = as.data.frame(inf_measures_sub)[,j],
                      mode = "markers")
            })

```


**Gráficos para medidas de Influência:**

<div class = "row">
<div class = "col-md-6">

```{r, fig.height=4, fig.width=4.7, warning=FALSE, message=FALSE}
lista[[1]] %>%
  plotly::layout(title = "Dfbetas - Dose", xaxis = list(title="índices"), yaxis = list(title="dfbetas"))

lista[[3]] %>%
  plotly::layout(title = "Cook's Distance", xaxis = list(title="índices"), yaxis = list(title="cook"))
```

</div>
<div class = "col-md-6">

```{r, fig.height=4, fig.width=4.7, warning=FALSE, message=FALSE}
lista[[2]] %>%
  plotly::layout(title = "Dffit", xaxis = list(title="índices"), yaxis = list(title="dffit"))

lista[[4]] %>%
  plotly::layout(title = "Leverage (hat)", xaxis = list(title="índices"), yaxis = list(title="leverage"))
```

</div>
</div>


---

---

### Referências Bibliográficas

---


AGRESTI, ALAN. *An Introduction to Categorical Data Analysis*. John Wiley & Sons, second edition, 2007.

NOTAS DE AULA. *Análise de Dados Categorizados*. Curso de Graduação em Estatística, UnB, 2018.

R CORE TEAM. *R: A language and environment for statistical computing*. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.

---