---
title: "**Horseshoe Crab 01**"
subtitle: "Regressão Logística - Análise de Dados Categorizados - Prova 3"
author: 
- Allan Vieira 14/0128492
- Caio Balena
- Frederico Lucca
- José Cezário

date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_folding: hide
    self_contained: false
    df_print: paged
---

<!-- self_contained: false --- para nao dar pau do plotly com firefox -->
<!-- df_print para as formas de imprimir data frames e tibbles -->
<!-- ver https://rmarkdown.rstudio.com/html_document_format.html -->

<!-- incluir no cabecalho: -->
<!-- always_allow_html: yes  -->
<!--para quando formos passar para pdf -->

<style>
body {
text-align: justify}
</style>

<!-- para justificar texto no markdown -->
<!-- https://stackoverflow.com/questions/43222169/how-to-justify-the-text-to-both-sides-when-knitting-html-in-rmarkdown -->

<!-- <style> -->
<!--   .col2 { -->
<!--     columns: 2 200px;         /* number of columns and width in pixels*/ -->
<!--     -webkit-columns: 2 200px; /* chrome, safari */ -->
<!--     -moz-columns: 2 200px;    /* firefox */ -->
<!--   } -->
<!--   .col3 { -->
<!--     columns: 3 100px; -->
<!--     -webkit-columns: 3 100px; -->
<!--     -moz-columns: 3 100px; -->
<!--   } -->
<!-- </style> -->
<!-- esse de cima funciona no output do RStudio, mas nao nos browsers -->
<!-- tb em: https://stackoverflow.com/questions/31753897/2-column-section-in-r-markdown -->


<!-- para acrescentar logo da unb no cabeçalho -->
<script>
   $(document).ready(function() {
     $head = $('#header');
     $head.prepend('<img src=\"unb3.png\" style=\"float: right;width: 150px;\"/>')
   });
</script>

---

---

<!-- ```{r, echo=FALSE} -->

<!-- htmltools::img(src = knitr::image_uri(file.path(R.home("doc"), "html", "logo.jpg")),  -->
<!--                alt = 'logo',  -->
<!--                style = 'position:absolute; top:0; right:0; padding:1px;') -->

<!-- ``` -->


**Carregamento de pacotes:**

Neste exemplo são utilizados os seguintes pacotes: *readr*, *dplyr*, *magrittr*, *tibble*, *broom*, *plotly*, *lmtest* e *pROC*. Para a confecção do documento html, é necessário o pacote *rmarkdown*.

```{r, message=FALSE, warning=FALSE}
# readr -- para leitura de dados
if (!require('readr')) install.packages('readr'); library('readr')

# dplyr -- para facilitar manipulacao de dados
if (!require('dplyr')) install.packages('dplyr'); library('dplyr')

# magrittr -- para facilitar manipulacao de dados
if (!require('magrittr')) install.packages('magrittr'); library('magrittr')

# tibble -- para facilitar manipulacao de dados
if (!require('tibble')) install.packages('tibble'); library('tibble')

# broom -- para facilitar manipulacao de dados
if (!require('broom')) install.packages('broom'); library('broom')

# plotly -- para os plots
if (!require('plotly')) install.packages('plotly'); library('plotly')

# lmtest -- para os testes de razao de verossimilhancas e para o teste de wald
if (!require('lmtest')) install.packages('lmtest'); library('lmtest')

# pROC -- para a curva ROC
if (!require('pROC')) install.packages('pROC'); library('pROC')

```

\s\s

**Carregamento dos dados**:

```{r, message=FALSE, warning=FALSE}
library(readr)
library(dplyr)

crabs <- readr::read_table2("/home/allan/Documents/1S2018/A_DADOS_CATEGORIZADOS/PARTE_GEORGE/parte2/exemplos/crabs/crabs.txt", col_names = FALSE)

crabs <- crabs %>%
  magrittr::set_colnames(c("color", "spine", "width", "satell", "weight")) %>%
  na.omit() %>%
  dplyr::mutate(y = dplyr::if_else(satell > 0, 1, 0), # resposta
                weight = weight/1000, # transformando peso em kg
                color = color - 1) # para escala de color de 1 a 4 


crabs
```

\s\s

**Frequência para as variáveis categóricas:**
```{r}
tabs <- sapply(crabs[, c("color", "spine", "satell", "y")], function(x) table)

tabs

```

\s\s

---

### **MO: MODELO LOGÍSTICO SEM EFEITO (SOMENTE INTERCEPTO)**

---

**Ajuste do modelo:**

```{r}

M0 <- glm(data=crabs, y ~ 1, family=binomial(link="logit"))

summary(M0)

```


**Model Fit Statistics**:

```{r}
# -2 Log L
-2*logLik(M0)

```



---

### **M1: MODELO LOGÍSTICO SOMENTE COM WIDTH**

---

**Ajuste do modelo:**

```{r}

M1 <- glm(data=crabs, y ~ width, family=binomial(link="logit"))

summary(M1)

```

\s\s

**Testes e demais estatísticas do modelo:**

```{r, message=FALSE, warning=FALSE}
# -2logLik
-2*logLik(M1)

# OR
exp(confint.default(M1)) # o metodo *.default* assume normalidade assintotica, por isso eh utilizado.


# testes para existência de regressão
# 1) razao de verossimilhancas
#library(lmtest)
lmtest::lrtest(M1)

# 2) teste de Wald
lmtest::waldtest(M1)


# 3) Score
anova(M1,test="Rao")

```



---

### **M2.1: MODELO LOGÍSTICO COM WIDTH E COLOR (ORDINAL)**
**AGRESTI - INTRODUCTION TO CATEGORIACAL DATATA ANALYSIS 2ND - PG.118**

---

\s\s

**Ajuste do modelo:**

```{r}

M2.1 <- glm(data=crabs, y ~ width + color, family=binomial(link="logit"))

summary(M2.1)

```

\s\s

**Testes e demais estatísticas do modelo:**

```{r, message=FALSE, warning=FALSE}
# -2logLik
-2*logLik(M2.1)

# IC OR
exp(confint.default(M2.1)) # o metodo *.default* assume normalidade assintotica, por isso eh utilizado.


# testes para existência de regressão
# 1) razao de verossimilhancas
#library(lmtest)
lmtest::lrtest(M2.1)

# 2) teste de Wald
lmtest::waldtest(M2.1)


# 3) Score
anova(M2.1,test="Rao")

```

\s\s

**Curvas Logísticas (segundo COLOR)**

Apenas para os valores preditos:

```{r, fig.width=9}

crabs %>%
  dplyr::mutate(color = factor(color, labels = c("Lt Med", "Medium", "Dk Med", "Dark"))) %>%
  #dplyr::group_by(color) %>%
  plotly::plot_ly(x=~width, y=~M2.1$fitted.values, #group=~color,
                           type="scatter", mode="markers", #color=~color, 
          split=~color) %>%
  plotly::layout(title = "Valores Preditos - COLOR(ORDINAL)")
  
```


\s\s

**Ajustes pré-plotagem:**

```{r}

# criando obs artificiais para suavizar a curva
x_limits <- crabs %>%
  dplyr::summarise(min(width)-2, max(width)+2) # obtendo os limites do eixo x


x <- seq(x_limits[[1]], x_limits[[2]], by=0.1) # criando varios ptos entre esses limites

# x <- seq(20,35, by=0.1) 

# ajustando as probabilidades (y_i's) para cada nivel de cor i
for (i in 1:4){
  assign(paste0("y",i), plogis(M2.1$coefficients[1]+M2.1$coefficients[2]*x+M2.1$coefficients[3]*i)  )
}

# salvando em uma lista
y_list <- list(y1,y2,y3,y4)
```


**Plot Completo:**

```{r, fig.width=9}

plotly::plot_ly(x = ~x, y = ~y1, type="scatter", mode="lines", name="Lt Med") %>%
  plotly::add_trace(y=~y2, x=~x , type="scatter", mode="lines", name="Medium") %>%
  plotly::add_trace(y=~y3, x=~x , type="scatter", mode="lines", name="Dk Med") %>%
  plotly::add_trace(y=~y4, x=~x , type="scatter", mode="lines", name="Dark") %>%
  plotly::layout(title = "Curvas Logísticas Ajustadas - COLOR(ORDINAL)")

```


\s\s

---

### **M2.2: MODELO LOGÍSTICO COM WIDTH E COLOR (NOMINAL)**
**AGRESTI - INTRODUCTION TO CDA 2ND - PG.116**

---

\s\s

**Preparação dos dados:**

```{r}

# soh precisamos tratar color como fator -- para a termos como variavel nominal:
crabs2 <- crabs %>%
  dplyr::mutate(color = factor(color, labels = c("Lt Med", "Medium", "Dk Med", "Dark")))

crabs2

```

\s\s

**Ajuste do modelo:**

```{r}
# quando criamos um fator, o R usa como referencia o level de numero mais baixoquando vai criar dummies a 
#... partir desse fator
# por isso eh necessario redefinir o level base com relevel()

# M2.2 <- glm(data=crabs2, y ~ width + relevel(factor(color), ref=4), family=binomial(link="logit"))
#ou:
M2.2 <- glm(data=crabs2, y ~ width + relevel(factor(color), ref='Dark'), family=binomial(link="logit"))

#M2.2 <- glm(data=crabs2, y ~ width + color, family=binomial(link="logit"))
summary(M2.2)

```


\s\s

**Testes e demais estatísticas do modelo:**

```{r, message=FALSE, warning=FALSE}
# -2logLik
-2*logLik(M2.2)

# IC OR
exp(confint.default(M2.2)) # o metodo *.default* assume normalidade assintotica, por isso eh utilizado.


# testes para existência de regressão
# 1) razao de verossimilhancas
#library(lmtest)
lmtest::lrtest(M2.2)

# 2) teste de Wald
lmtest::waldtest(M2.2)


# 3) Score
anova(M2.2,test="Rao")

```

\s\s

**Curvas Logísticas (segundo COLOR)**

\s\s

**Ajustes pré-plotagem:**


```{r}
# NAO PRECISA !
# ajustando os dados para termos dummy columns
# extraindo a coluna cor
color <- crabs2 %>%
  dplyr::pull(color)

# coercer como fator
color <- as.factor(color)

# deixando a base como 'Dark'
color <- relevel(color, ref='Dark')

# dummies
dummies_cols <- model.matrix(~color)
dummies_cols <- dplyr::as_data_frame(dummies_cols[,-1])

crabs3 <- crabs2 %>%
  dplyr::bind_cols(., dummies_cols) %>%
  # dplyr::select_(as.name(
  dplyr::rename(colorLtMed = `colorLt Med`,
                colorMed = colorMedium,
                colorDkMed = `colorDk Med`)

# ajustando modelo
M2.2_alt <- glm(data=crabs3, y ~ width + colorLtMed + colorMed + colorDkMed, family=binomial(link="logit"))
# summary(M2.2)
summary(M2.2_alt) # ok, bateu!

```


```{r}

# Create a temporary data frame of hypothetical values
temp.data <- data.frame(width = seq(20, 34, 0.11),
                        color = c(rep("Lt Med", 128),
                                     rep("Medium", 128), 
                                     rep("Dk Med", 128),
                                     rep("Dark", 128)) ) # o R vai reciclar o tamanho da coluna width para 4x 128


# Predict the fitted values given the model and hypothetical data
predicted.data <- as.data.frame(predict(M2.2, newdata = temp.data, 
                                        type="link", se=TRUE))

# Combine the hypothetical data and predicted values
new.data <- cbind(temp.data, predicted.data)

# Calculate confidence intervals
std <- qnorm(0.95 / 2 + 0.5)
new.data$ymin <- M2.2$family$linkinv(new.data$fit - std * new.data$se)
new.data$ymax <- M2.2$family$linkinv(new.data$fit + std * new.data$se)
new.data$fit <- M2.2$family$linkinv(new.data$fit)  # Rescale to 0-1

# Plot everything
p <- ggplot(crabs2, aes(x=width, y=y)) 
p + geom_point() + 
  geom_ribbon(data=new.data, aes(y=fit, ymin=ymin, ymax=ymax, 
                                       fill=as.factor(color)), alpha=0.5) + 
  geom_line(data=new.data, aes(y=fit, colour=as.factor(color))) + 
  facet_wrap(~color)+
  labs(x="Temperature", y="Thermal Distress") 
```




```{r}

# plot:
x_limits <- crabs2 %>%
  dplyr::summarise(min(width), max(width)) # obtendo os limites do eixo x


x <- seq(x_limits[[1]], x_limits[[2]], by=0.1) # criando varios ptos entre esses limites


# ajustando as probabilidades (y_i's) para cada nivel de cor i
# temos mais dois coeficientes no modelo agora, mas cuja o valor que multiplica eh 1

y4 <- plogis(M2.2$coefficients[1]+M2.2$coefficients[2]*x) # modelo com color 0 0 0 (base 4 - Dark)

for(j in 1:3){
  assign(paste0("y",j), plogis(M2.2$coefficients[1]+M2.2$coefficients[2]*x+M2.2$coefficients[j+2])  ) # pula 2 coeficientes por causa do intercepto e do with agora
}

# summary(M2.2)

y_list <- list(y1,y2,y3,y4)
```


```{r}

y_all <- Reduce('c', y_list)

library(ggplot2)

# começa do Dark pq foi a base
new.data <- dplyr::as_data_frame(cbind(x, y_all)) %>%
  dplyr::mutate(color = factor(rep(c("Lt Med", "Medium", "Dk Med","Dark"), each=length(y1)) ))#, 
                               # labels = c("Lt Med", "Medium", "Dk Med", "Dark") )) # passamos as labels de novo para o ggplot nao ordenar alfabeticamente que eh o default
                               

new.data %>%
  ggplot(aes(x=x, y=y_all))+
  geom_line()+
  facet_wrap(facets=~color)+
  stat_smooth(method = "glm", method.args = list(family = "binomial"))
  #ou 
  # stat_smooth(method = "glm", method.args = list(family = "binomial"))







carbs2 %>%
  ggplot(aes(x=x, y=))


# ideia: passar os dados para o formato wide para fazer subplots no plotly
library(reshape2)

crabs_w <- crabs2 %>%
  melt()

# !! nao precisa ! eh soh fazer um por um

fix.axis <- list(autotick = FALSE, ticks = "outside", tick0 = 20, ticklen = 13, dtick = 2.5)

p1 <- plotly::plot_ly(x = ~x, y = ~y1) %>%
  plotly::add_lines(name = ~"unemploy") %>%
  plotly::add_ribbons(data = broom::augment(M2.2),
                      ymin = y1 - qnorm(0.975) * .se.fit,
                      ymax = y1 + qnorm(0.975) * .se.fit)

model <- broom::augment(M2.2) 

colnames(model)[2] <- "color"

model <- model %>%
  dplyr::group_by(color) %>%
  summarise()



p1 <- plotly::plot_ly(x = ~x, y = ~y1) %>%
  plotly::add_lines(name = ~"unemploy")# %>%
  # plotly::layout(xaxis = fix.axis)

p2 <- plotly::plot_ly(x = ~x, y = ~y2) %>%
  plotly::add_lines(name = ~"uempmed")# %>%
  # plotly::layout(xaxis = fix.axis)

s1 <- plotly::subplot(p1, p2, shareY = TRUE)

p3 <- plotly::plot_ly(x = ~x, y = ~y3) %>%
  plotly::add_lines(name = ~"uempmed")
p4 <- plotly::plot_ly(x = ~x, y = ~y4) %>%
  plotly::add_lines(name = ~"uempmed")

s2 <- plotly::subplot(p1, p2, nrows = 2, shareY = TRUE)


p <- plotly::subplot(p1, p2, p3, p4, nrows = 2, shareX = TRUE, shareY = TRUE)




# FAZER UM NOVO MODELO PARA CADA COR
lt <- crabs2 %>%
  dplyr::filter(color == "Lt Med")

str(lt)

mod1 <- glm(y ~ width, data=lt, family=binomial(link="logit"))
# plot:
x_limits <- crabs2 %>%
  dplyr::summarise(min(width), max(width)) # obtendo os limites do eixo x

x <- seq(x_limits[[1]], x_limits[[2]], by=0.1) # criando varios ptos entre esses limites

y <- plogis(M2.2$coefficients[1]+M2.2$coefficients[2]*x) # modelo com color 0 0 0 (base 4 - Dark)

temp.data = data.frame(width = x)

# Predict the fitted values given the model and hypothetical data
predicted.data <- as.data.frame(predict(mod1, newdata = temp.data, 
                                        type="link", se=TRUE))

# Combine the hypothetical data and predicted values
new.data <- cbind(temp.data, predicted.data)

# Calculate confidence intervals
std <- qnorm(0.95 / 2 + 0.5)
new.data$ymin <- mod1$family$linkinv(new.data$fit - std * new.data$se)
new.data$ymax <- mod1$family$linkinv(new.data$fit + std * new.data$se)
new.data$fit <- mod1$family$linkinv(new.data$fit)  # Rescale to 0-1

plotly::plot_ly(x = ~x, y = ~y, name = 'fitted', type = 'scatter', mode = 'lines') %>%
  # plotly::add_trace(x= ~dose, y = ~prop, name = 'resp', mode = 'markers', data=beetles) %>%
  plotly::add_ribbons(data = new.data,
              ymin = ~ymin,
              ymax = ~ymax,
              line = list(color = 'rgba(138,43,226, 0.05)', opacity = 0.1),
              fillcolor = 'rgba(138,43,226, 0.2)', opacity = 0.25,
              name = "95% conf.") %>%
  plotly::layout(title = "Beetle Mortality Data")


```





Apenas para os valores preditos:

```{r, fig.width=9}

crabs2 %>%
  # dplyr::mutate(color = factor(color, labels = c("Lt Med", "Medium", "Dk Med", "Dark"))) %>%
  #dplyr::group_by(color) %>%
  plotly::plot_ly(x=~width, y=~M2.2$fitted.values, #group=~color,
                           type="scatter", mode="markers", #color=~color, 
          split=~color) %>%
  plotly::layout(title = "Valores Preditos - COLOR(NOMINAL)")
  
```



```{r, fig.width=9}
# plot:
x_limits <- crabs2 %>%
  dplyr::summarise(min(width)-2, max(width)+2) # obtendo os limites do eixo x


x <- seq(x_limits[[1]], x_limits[[2]], by=0.1) # criando varios ptos entre esses limites

# x <- seq(20,35, by=0.1)

# ajustando as probabilidades (y_i's) para cada nivel de cor i
# temos mais dois coeficientes no modelo agora, mas cuja o valor que multiplica eh 1


y1 <- plogis(M2.2$coefficients[1]+M2.2$coefficients[2]*x) # modelo com color 0 0 0 (base 4 - Dark)

for(j in 2:4){
  assign(paste0("y",i), plogis(M2.2$coefficients[1]+M2.2$coefficients[2]*x+M2.2$coefficients[i+1])  )
}



y_list <- list(y1,y2,y3,y4)

# precisa ser nessa ordem para respeitar as cores do grafico anterior
plotly::plot_ly(x = ~x, y = ~y4, type="scatter", mode="lines", name="Lt Med") %>%
  plotly::add_trace(y=~y3, x=~x , type="scatter", mode="lines", name="Medium") %>%
  plotly::add_trace(y=~y2, x=~x , type="scatter", mode="lines", name="Dk Med") %>%
  plotly::add_trace(y=~y1, x=~x , type="scatter", mode="lines", name="Dark") %>%
  plotly::layout(title = "Curvas Logísticas Ajustadas - COLOR(NOMINAL)")

```



---

#### **SELEÇÃO DE VARIÁVEIS PARA O MODELO M2.2: MODELO LOGÍSTICO COM WIDTH E COLOR (NOMINAL)**

**Preparação dos dados:**

```{r}

# soh precisamos tratar color como fator:
# ficando apenas com as variaveis de interesse y, width, color
crabs3 <- crabs2 %>%
  dplyr::select(y, width, color)


head(crabs3)

```


**Seleção Automática de Modelos:**

*Backward* a partir do modelo completo *y $\sim$ width + Lt Med + Medium + Dk Med*:

```{r}
# ajustando os dados
# precisamos fazer isso, para que a funcao step reconheça as variaveis dummy
# step(M2.2) # embora glm reconheça as dummy, a funcao step trata como uma variavel color soh com 3 g.l.

df <- as.data.frame(crabs3)
str(df)
m <- model.matrix(~color-1, data=crabs3)
df <- cbind(crabs3[,-3], m[,-4]) # tirando Dark
colnames(df) <- c("y", "width", "Lt_Med", "Medium", "Dk_Med")

tibble::as.tibble(df)


# modelo completo:
fullmod <- glm(data=df, y ~ ., family=binomial(link="logit"))

# olhar para os AIC's mais baixos

step(fullmod) # esse jah eh o melhor no backward

```

*Forward* a partir do modelo simples:

```{r}

modmin <- glm(data=df, y~1, family=binomial(link="logit"))
step(modmin, direction = "forward", scope = ~ width + Lt_Med + Medium + Dk_Med) #ok!


```


**Curva ROC para os modelo selecionados:**

```{r, fig.width=9}
library(pROC)
#https://stackoverflow.com/questions/27584099/plot-multiple-roc-curves-for-logistic-regression-model-in-r



y <- crabs2[["y"]]

# modelo 2.2 (resultante do backward)
preds1 <- predict(M2.2)
roc1=roc(y ~ preds1)

# modelo (resultante do forward)

mod_fwd <- glm(data=df, y ~ width + Medium, family=binomial(link="logit"))
preds2 <- predict(mod_fwd)
roc2=roc(y ~ preds2)

# plot(roc1)

# help(plot.roc)

# roc1 %>% 
  plotly::plot_ly(x = ~(1-roc1$specificities), y = ~roc1$sensitivities, type="scatter", mode="markers", name="ROC 1")%>%
    plotly::add_trace(x = c(0, 1), y= c(0, 1), mode = "lines", name="abline") %>%
    plotly::add_trace(x = ~(1-roc2$specificities), y = ~roc2$sensitivities, type="scatter", mode="markers", name="ROC 2") %>%
    plotly::layout(title = "Curvas ROC", xaxis=list(title="1-especificidade"), yaxis=list(title="sensibilidade"))
    

```

---

---

---

### Referências Bibliográficas

---


AGRESTI, ALAN. *An Introduction to Categorical Data Analysis*. John Wiley & Sons, second edition, 2007.

NOTAS DE AULA. *Análise de Dados Categorizados*. Curso de Graduação em Estatística, UnB, 2018.

R CORE TEAM. *R: A language and environment for statistical computing*. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.

---